{"version":3,"sources":["../node_modules/fft.js/lib/fft.js","../node_modules/next-pow-2/np2.js","../node_modules/pitchy/lib/index.mjs","js/getNoteFromPitch.js","js/tuners.js","js/render.js","js/main.js"],"names":["toConsumableArray","arr","Array","isArray","i","arr2","length","from","autocorrelate","input","fft","paddedInput","size","forEach","val","idx","fill","tmp","createComplexArray","realTransform","completeSpectrum","tmp2","inverseTransform","result","_i","ndsf","rPrimeArray","m","map","rPrime","mPrime","i2","getKeyMaximumIndices","keyIndices","lookingForMaximum","max","maxIndex","push","findPitch","sampleRate","ndsfArray","keyMaximumIndices","K","nMax","Math","apply","resultIndex","find","notes","baseFrequency","notesNumber","frequencyRange","min","module","exports","pitch","log2","noteIndex","abs","round","name","cents","octave","floor","standartTuning","getTuner","note","tune","some","lowerOffset","Infinity","reduce","acc","item","offset","chromatic","tuner","standart","canvas","document","getElementById","ctx","getContext","arcX","width","arcY","height","arcRadius","arcHeight","startAngleIndex","endAngleIndex","centerAngleIndex","centsPerAngleIndex","startAngle","PI","endAngle","digits","step","digitsOffsetFromArc","tickLength","tickWidth","digitsAngles","digit","index","digitsCoords","x","cos","y","sin","ticksCoords","fromX","fromY","toX","toY","arrowWidth","arrowLength","noteFontSize","noteY","animationFramesCount","lightsElements","querySelectorAll","state","arrowAngleIndex","lastAnimationId","drawLightbulbs","lightbulbType","classList","contains","add","remove","drawArc","beginPath","arc","lineWidth","strokeStyle","stroke","drawNote","font","fillStyle","textAlign","textBaseline","fillText","drawDigits","drawTicks","moveTo","lineTo","lineCap","drawArrow","angle","drawScale","clearRect","noteName","angleIndexStep","animateArrow","window","requestAnimationFrame","cancelAnimationFrame","tuners","getNote","selectElement","querySelector","innerHTML","Object","keys","key","join","addEventListener","value","navigator","mediaDevices","getUserMedia","audio","then","stream","context","AudioContext","source","createMediaStreamSource","analyser","createAnalyser","fftSize","data","Float32Array","destination","createMediaStreamDestination","connect","setInterval","getFloatTimeDomainData","clarity"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"f0c1949b2744828a2be8d013b1b7fa83.map","sourcesContent":["'use strict';\n\nfunction FFT(size) {\n  this.size = size | 0;\n  if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n    throw new Error('FFT size must be a power of two and bigger than 1');\n\n  this._csize = size << 1;\n\n  // NOTE: Use of `var` is intentional for old V8 versions\n  var table = new Array(this.size * 2);\n  for (var i = 0; i < table.length; i += 2) {\n    const angle = Math.PI * i / this.size;\n    table[i] = Math.cos(angle);\n    table[i + 1] = -Math.sin(angle);\n  }\n  this.table = table;\n\n  // Find size's power of two\n  var power = 0;\n  for (var t = 1; this.size > t; t <<= 1)\n    power++;\n\n  // Calculate initial step's width:\n  //   * If we are full radix-4 - it is 2x smaller to give inital len=8\n  //   * Otherwise it is the same as `power` to give len=4\n  this._width = power % 2 === 0 ? power - 1 : power;\n\n  // Pre-compute bit-reversal patterns\n  this._bitrev = new Array(1 << this._width);\n  for (var j = 0; j < this._bitrev.length; j++) {\n    this._bitrev[j] = 0;\n    for (var shift = 0; shift < this._width; shift += 2) {\n      var revShift = this._width - shift - 2;\n      this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n    }\n  }\n\n  this._out = null;\n  this._data = null;\n  this._inv = 0;\n}\nmodule.exports = FFT;\n\nFFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {\n  var res = storage || new Array(complex.length >>> 1);\n  for (var i = 0; i < complex.length; i += 2)\n    res[i >>> 1] = complex[i];\n  return res;\n};\n\nFFT.prototype.createComplexArray = function createComplexArray() {\n  const res = new Array(this._csize);\n  for (var i = 0; i < res.length; i++)\n    res[i] = 0;\n  return res;\n};\n\nFFT.prototype.toComplexArray = function toComplexArray(input, storage) {\n  var res = storage || this.createComplexArray();\n  for (var i = 0; i < res.length; i += 2) {\n    res[i] = input[i >>> 1];\n    res[i + 1] = 0;\n  }\n  return res;\n};\n\nFFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {\n  var size = this._csize;\n  var half = size >>> 1;\n  for (var i = 2; i < half; i += 2) {\n    spectrum[size - i] = spectrum[i];\n    spectrum[size - i + 1] = -spectrum[i + 1];\n  }\n};\n\nFFT.prototype.transform = function transform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 0;\n  this._transform4();\n  this._out = null;\n  this._data = null;\n};\n\nFFT.prototype.realTransform = function realTransform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 0;\n  this._realTransform4();\n  this._out = null;\n  this._data = null;\n};\n\nFFT.prototype.inverseTransform = function inverseTransform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 1;\n  this._transform4();\n  for (var i = 0; i < out.length; i++)\n    out[i] /= this.size;\n  this._out = null;\n  this._data = null;\n};\n\n// radix-4 implementation\n//\n// NOTE: Uses of `var` are intentional for older V8 version that do not\n// support both `let compound assignments` and `const phi`\nFFT.prototype._transform4 = function _transform4() {\n  var out = this._out;\n  var size = this._csize;\n\n  // Initial step (permute and transform)\n  var width = this._width;\n  var step = 1 << width;\n  var len = (size / step) << 1;\n\n  var outOff;\n  var t;\n  var bitrev = this._bitrev;\n  if (len === 4) {\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleTransform2(outOff, off, step);\n    }\n  } else {\n    // len === 8\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleTransform4(outOff, off, step);\n    }\n  }\n\n  // Loop through steps in decreasing order\n  var inv = this._inv ? -1 : 1;\n  var table = this.table;\n  for (step >>= 2; step >= 2; step >>= 2) {\n    len = (size / step) << 1;\n    var quarterLen = len >>> 2;\n\n    // Loop through offsets in the data\n    for (outOff = 0; outOff < size; outOff += len) {\n      // Full case\n      var limit = outOff + quarterLen;\n      for (var i = outOff, k = 0; i < limit; i += 2, k += step) {\n        const A = i;\n        const B = A + quarterLen;\n        const C = B + quarterLen;\n        const D = C + quarterLen;\n\n        // Original values\n        const Ar = out[A];\n        const Ai = out[A + 1];\n        const Br = out[B];\n        const Bi = out[B + 1];\n        const Cr = out[C];\n        const Ci = out[C + 1];\n        const Dr = out[D];\n        const Di = out[D + 1];\n\n        // Middle values\n        const MAr = Ar;\n        const MAi = Ai;\n\n        const tableBr = table[k];\n        const tableBi = inv * table[k + 1];\n        const MBr = Br * tableBr - Bi * tableBi;\n        const MBi = Br * tableBi + Bi * tableBr;\n\n        const tableCr = table[2 * k];\n        const tableCi = inv * table[2 * k + 1];\n        const MCr = Cr * tableCr - Ci * tableCi;\n        const MCi = Cr * tableCi + Ci * tableCr;\n\n        const tableDr = table[3 * k];\n        const tableDi = inv * table[3 * k + 1];\n        const MDr = Dr * tableDr - Di * tableDi;\n        const MDi = Dr * tableDi + Di * tableDr;\n\n        // Pre-Final values\n        const T0r = MAr + MCr;\n        const T0i = MAi + MCi;\n        const T1r = MAr - MCr;\n        const T1i = MAi - MCi;\n        const T2r = MBr + MDr;\n        const T2i = MBi + MDi;\n        const T3r = inv * (MBr - MDr);\n        const T3i = inv * (MBi - MDi);\n\n        // Final values\n        const FAr = T0r + T2r;\n        const FAi = T0i + T2i;\n\n        const FCr = T0r - T2r;\n        const FCi = T0i - T2i;\n\n        const FBr = T1r + T3i;\n        const FBi = T1i - T3r;\n\n        const FDr = T1r - T3i;\n        const FDi = T1i + T3r;\n\n        out[A] = FAr;\n        out[A + 1] = FAi;\n        out[B] = FBr;\n        out[B + 1] = FBi;\n        out[C] = FCr;\n        out[C + 1] = FCi;\n        out[D] = FDr;\n        out[D + 1] = FDi;\n      }\n    }\n  }\n};\n\n// radix-2 implementation\n//\n// NOTE: Only called for len=4\nFFT.prototype._singleTransform2 = function _singleTransform2(outOff, off,\n                                                             step) {\n  const out = this._out;\n  const data = this._data;\n\n  const evenR = data[off];\n  const evenI = data[off + 1];\n  const oddR = data[off + step];\n  const oddI = data[off + step + 1];\n\n  const leftR = evenR + oddR;\n  const leftI = evenI + oddI;\n  const rightR = evenR - oddR;\n  const rightI = evenI - oddI;\n\n  out[outOff] = leftR;\n  out[outOff + 1] = leftI;\n  out[outOff + 2] = rightR;\n  out[outOff + 3] = rightI;\n};\n\n// radix-4\n//\n// NOTE: Only called for len=8\nFFT.prototype._singleTransform4 = function _singleTransform4(outOff, off,\n                                                             step) {\n  const out = this._out;\n  const data = this._data;\n  const inv = this._inv ? -1 : 1;\n  const step2 = step * 2;\n  const step3 = step * 3;\n\n  // Original values\n  const Ar = data[off];\n  const Ai = data[off + 1];\n  const Br = data[off + step];\n  const Bi = data[off + step + 1];\n  const Cr = data[off + step2];\n  const Ci = data[off + step2 + 1];\n  const Dr = data[off + step3];\n  const Di = data[off + step3 + 1];\n\n  // Pre-Final values\n  const T0r = Ar + Cr;\n  const T0i = Ai + Ci;\n  const T1r = Ar - Cr;\n  const T1i = Ai - Ci;\n  const T2r = Br + Dr;\n  const T2i = Bi + Di;\n  const T3r = inv * (Br - Dr);\n  const T3i = inv * (Bi - Di);\n\n  // Final values\n  const FAr = T0r + T2r;\n  const FAi = T0i + T2i;\n\n  const FBr = T1r + T3i;\n  const FBi = T1i - T3r;\n\n  const FCr = T0r - T2r;\n  const FCi = T0i - T2i;\n\n  const FDr = T1r - T3i;\n  const FDi = T1i + T3r;\n\n  out[outOff] = FAr;\n  out[outOff + 1] = FAi;\n  out[outOff + 2] = FBr;\n  out[outOff + 3] = FBi;\n  out[outOff + 4] = FCr;\n  out[outOff + 5] = FCi;\n  out[outOff + 6] = FDr;\n  out[outOff + 7] = FDi;\n};\n\n// Real input radix-4 implementation\nFFT.prototype._realTransform4 = function _realTransform4() {\n  var out = this._out;\n  var size = this._csize;\n\n  // Initial step (permute and transform)\n  var width = this._width;\n  var step = 1 << width;\n  var len = (size / step) << 1;\n\n  var outOff;\n  var t;\n  var bitrev = this._bitrev;\n  if (len === 4) {\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n    }\n  } else {\n    // len === 8\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n    }\n  }\n\n  // Loop through steps in decreasing order\n  var inv = this._inv ? -1 : 1;\n  var table = this.table;\n  for (step >>= 2; step >= 2; step >>= 2) {\n    len = (size / step) << 1;\n    var halfLen = len >>> 1;\n    var quarterLen = halfLen >>> 1;\n    var hquarterLen = quarterLen >>> 1;\n\n    // Loop through offsets in the data\n    for (outOff = 0; outOff < size; outOff += len) {\n      for (var i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n        var A = outOff + i;\n        var B = A + quarterLen;\n        var C = B + quarterLen;\n        var D = C + quarterLen;\n\n        // Original values\n        var Ar = out[A];\n        var Ai = out[A + 1];\n        var Br = out[B];\n        var Bi = out[B + 1];\n        var Cr = out[C];\n        var Ci = out[C + 1];\n        var Dr = out[D];\n        var Di = out[D + 1];\n\n        // Middle values\n        var MAr = Ar;\n        var MAi = Ai;\n\n        var tableBr = table[k];\n        var tableBi = inv * table[k + 1];\n        var MBr = Br * tableBr - Bi * tableBi;\n        var MBi = Br * tableBi + Bi * tableBr;\n\n        var tableCr = table[2 * k];\n        var tableCi = inv * table[2 * k + 1];\n        var MCr = Cr * tableCr - Ci * tableCi;\n        var MCi = Cr * tableCi + Ci * tableCr;\n\n        var tableDr = table[3 * k];\n        var tableDi = inv * table[3 * k + 1];\n        var MDr = Dr * tableDr - Di * tableDi;\n        var MDi = Dr * tableDi + Di * tableDr;\n\n        // Pre-Final values\n        var T0r = MAr + MCr;\n        var T0i = MAi + MCi;\n        var T1r = MAr - MCr;\n        var T1i = MAi - MCi;\n        var T2r = MBr + MDr;\n        var T2i = MBi + MDi;\n        var T3r = inv * (MBr - MDr);\n        var T3i = inv * (MBi - MDi);\n\n        // Final values\n        var FAr = T0r + T2r;\n        var FAi = T0i + T2i;\n\n        var FBr = T1r + T3i;\n        var FBi = T1i - T3r;\n\n        out[A] = FAr;\n        out[A + 1] = FAi;\n        out[B] = FBr;\n        out[B + 1] = FBi;\n\n        // Output final middle point\n        if (i === 0) {\n          var FCr = T0r - T2r;\n          var FCi = T0i - T2i;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          continue;\n        }\n\n        // Do not overwrite ourselves\n        if (i === hquarterLen)\n          continue;\n\n        // In the flipped case:\n        // MAi = -MAi\n        // MBr=-MBi, MBi=-MBr\n        // MCr=-MCr\n        // MDr=MDi, MDi=MDr\n        var ST0r = T1r;\n        var ST0i = -T1i;\n        var ST1r = T0r;\n        var ST1i = -T0i;\n        var ST2r = -inv * T3i;\n        var ST2i = -inv * T3r;\n        var ST3r = -inv * T2i;\n        var ST3i = -inv * T2r;\n\n        var SFAr = ST0r + ST2r;\n        var SFAi = ST0i + ST2i;\n\n        var SFBr = ST1r + ST3i;\n        var SFBi = ST1i - ST3r;\n\n        var SA = outOff + quarterLen - i;\n        var SB = outOff + halfLen - i;\n\n        out[SA] = SFAr;\n        out[SA + 1] = SFAi;\n        out[SB] = SFBr;\n        out[SB + 1] = SFBi;\n      }\n    }\n  }\n};\n\n// radix-2 implementation\n//\n// NOTE: Only called for len=4\nFFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff,\n                                                                     off,\n                                                                     step) {\n  const out = this._out;\n  const data = this._data;\n\n  const evenR = data[off];\n  const oddR = data[off + step];\n\n  const leftR = evenR + oddR;\n  const rightR = evenR - oddR;\n\n  out[outOff] = leftR;\n  out[outOff + 1] = 0;\n  out[outOff + 2] = rightR;\n  out[outOff + 3] = 0;\n};\n\n// radix-4\n//\n// NOTE: Only called for len=8\nFFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff,\n                                                                     off,\n                                                                     step) {\n  const out = this._out;\n  const data = this._data;\n  const inv = this._inv ? -1 : 1;\n  const step2 = step * 2;\n  const step3 = step * 3;\n\n  // Original values\n  const Ar = data[off];\n  const Br = data[off + step];\n  const Cr = data[off + step2];\n  const Dr = data[off + step3];\n\n  // Pre-Final values\n  const T0r = Ar + Cr;\n  const T1r = Ar - Cr;\n  const T2r = Br + Dr;\n  const T3r = inv * (Br - Dr);\n\n  // Final values\n  const FAr = T0r + T2r;\n\n  const FBr = T1r;\n  const FBi = -T3r;\n\n  const FCr = T0r - T2r;\n\n  const FDr = T1r;\n  const FDi = T3r;\n\n  out[outOff] = FAr;\n  out[outOff + 1] = 0;\n  out[outOff + 2] = FBr;\n  out[outOff + 3] = FBi;\n  out[outOff + 4] = FCr;\n  out[outOff + 5] = 0;\n  out[outOff + 6] = FDr;\n  out[outOff + 7] = FDi;\n};\n","module.exports = function(v) {\n  v += v === 0\n  --v\n  v |= v >>> 1\n  v |= v >>> 2\n  v |= v >>> 4\n  v |= v >>> 8\n  v |= v >>> 16\n  return v + 1\n}\n","import FFT from 'fft.js';\nimport np2 from 'next-pow-2';\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/*\n * Copyright 2018 Ian Johnson\n *\n * This is free software, distributed under the MIT license.  A copy of the\n * license can be found in the LICENSE file in the project root, or at\n * https://opensource.org/licenses/MIT.\n */\n/**\n * Return an array containing the autocorrelated input data.\n *\n * @param {number[]} input The input data.\n * @return {number[]} The autocorrelated input data.\n */\nfunction autocorrelate(input) {\n  // We need to double the input length to get correct results, and the FFT\n  // algorithm we use requires a size that's a power of 2.\n  var fft = new FFT(np2(2 * input.length));\n\n  // Step 0: pad the input array with zeros.\n  var paddedInput = new Array(fft.size);\n  input.forEach(function (val, idx) {\n    paddedInput[idx] = val;\n  });\n  paddedInput.fill(0, input.length);\n\n  // Step 1: get the DFT of the input array.\n  var tmp = fft.createComplexArray();\n  fft.realTransform(tmp, paddedInput);\n  // We need to fill in the right half of the array too.\n  fft.completeSpectrum(tmp);\n  // Step 2: multiply each entry by its conjugate.\n  for (var i = 0; i < tmp.length; i += 2) {\n    tmp[i] = tmp[i] * tmp[i] + tmp[i + 1] * tmp[i + 1];\n    tmp[i + 1] = 0;\n  }\n  // Step 3: perform the inverse transform.\n  var tmp2 = fft.createComplexArray();\n  fft.inverseTransform(tmp2, tmp);\n\n  // This last result (the inverse transform) contains the autocorrelation\n  // data, which is completely real.\n  var result = new Array(input.length);\n  for (var _i = 0; _i < input.length; _i++) {\n    result[_i] = tmp2[2 * _i];\n  }\n  return result;\n}\n\n/**\n * Return an array containing the computed values of the NDSF used in MPM.\n *\n * Specifically, this is equation (9) in the McLeod pitch method paper.\n */\nfunction ndsf(input) {\n  // The function r'(tau) is the autocorrelation.\n  var rPrimeArray = autocorrelate(input);\n  // The function m'(tau) (defined in equation (6)) can be computed starting\n  // with m'(0), which is equal to 2r'(0), and then iteratively modified to get\n  // m'(1), m'(2), etc.  For example, to get m'(1), we take m'(0) and subtract\n  // x_0^2 and x_{W-1}^2.  Then, to get m'(2), we take m'(1) and subtract x_1^2\n  // and x_{W-2}^2, and further values are similar.  We use m below as this\n  // value.\n  //\n  // The resulting array values are 2 * r'(tau) / m'(tau).\n  var m = 2 * rPrimeArray[0];\n  if (m === 0) {\n    // We don't want to trigger any divisions by zero; if the given input data\n    // consists of all zeroes, then so should the output data.\n    var result = new Array(rPrimeArray.length);\n    result.fill(0);\n    return result;\n  } else {\n    return rPrimeArray.map(function (rPrime, i) {\n      var mPrime = m;\n      var i2 = input.length - i - 1;\n      m -= input[i] * input[i] + input[i2] * input[i2];\n\n      return 2 * rPrime / mPrime;\n    });\n  }\n}\n\n/**\n * Return an array of all the key maximum positions in the given input array.\n *\n * In McLeod's paper, a key maximum is the highest maximum between a positively\n * sloped zero crossing and a negatively sloped one.\n *\n * TODO: the paper by McLeod proposes doing parabolic interpolation to get more\n * accurate key maxima; right now this implementation doesn't do that, but it\n * could be implemented later.\n */\nfunction getKeyMaximumIndices(input) {\n  // The indices of the key maxima.\n  var keyIndices = [];\n  // Whether the last zero crossing found was positively sloped; equivalently,\n  // whether we're looking for a key maximum.\n  var lookingForMaximum = false;\n  // The largest local maximum found so far.\n  var max = void 0;\n  // The index of the largest local maximum so far.\n  var maxIndex = -1;\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i - 1] < 0 && input[i] > 0) {\n      lookingForMaximum = true;\n      maxIndex = i;\n      max = input[i];\n    } else if (input[i - 1] > 0 && input[i] < 0) {\n      lookingForMaximum = false;\n      if (maxIndex !== -1) {\n        keyIndices.push(maxIndex);\n      }\n    } else if (lookingForMaximum && input[i] > max) {\n      max = input[i];\n      maxIndex = i;\n    }\n  }\n\n  return keyIndices;\n}\n\n/**\n * Return the pitch detected using McLeod Pitch Method (MPM) along with a\n * measure of its clarity.\n *\n * The clarity is a value between 0 and 1 (potentially inclusive) that\n * represents how \"clear\" the pitch was.  A clarity value of 1 indicates that\n * the pitch was very distinct, while lower clarity values indicate less\n * definite pitches.\n *\n * MPM is described in the paper 'A Smarter Way to Find Pitch' by Philip McLeod\n * and Geoff Wyvill\n * (http://miracle.otago.ac.nz/tartini/papers/A_Smarter_Way_to_Find_Pitch.pdf).\n *\n * @param {number[]} input The time-domain input data.\n * @param {number} sampleRate The sample rate at which the input data was\n * collected.\n * @return {[number, number]} The detected pitch, in Hz, followed by the\n * clarity.\n */\nfunction findPitch(input, sampleRate) {\n  var ndsfArray = ndsf(input);\n  var keyMaximumIndices = getKeyMaximumIndices(ndsfArray);\n  if (keyMaximumIndices.length === 0) {\n    // No key maxima means that we either don't have enough data to analyze or\n    // that the data was flawed (such as an input array of zeroes).\n    return [0, 0];\n  }\n  // The constant k mentioned in section 5.  TODO: make this configurable.\n  var K = 0.9;\n  // The highest key maximum.\n  var nMax = Math.max.apply(Math, toConsumableArray(keyMaximumIndices.map(function (i) {\n    return ndsfArray[i];\n  })));\n  // Following the paper, we return the pitch corresponding to the first key\n  // maximum higher than K * nMax.\n  var resultIndex = keyMaximumIndices.find(function (i) {\n    return ndsfArray[i] >= K * nMax;\n  });\n\n  return [sampleRate / resultIndex, ndsfArray[resultIndex]];\n}\n\nexport { autocorrelate, findPitch };\n","const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n\nconst baseFrequency = 440;\nconst notesNumber = notes.length;\nconst frequencyRange = {\n  min: 27.5,\n  max: 1318.5,\n};\n\nmodule.exports = (pitch) => {\n  if (pitch < frequencyRange.min || pitch > frequencyRange.max) {\n    return false;\n  }\n\n  const result = (notesNumber * Math.log2(pitch / baseFrequency)) + ((notesNumber * 4) + 9);\n  const noteIndex = Math.abs(Math.round(result) % notesNumber);\n\n  const name = notes[noteIndex];\n  const cents = Math.round((result - Math.round(result)) * 100);\n  const octave = Math.floor(result / notesNumber) + (noteIndex === 0 && cents < 0 ? 1 : 0);\n\n  return { name, cents, octave };\n};\n","import getNoteFromPitch from './getNoteFromPitch';\n\nconst standartTuning = [\n  { name: 'E', octave: 2, pitch: 82.41 },\n  { name: 'A', octave: 2, pitch: 110 },\n  { name: 'D', octave: 3, pitch: 146.83 },\n  { name: 'G', octave: 3, pitch: 196 },\n  { name: 'B', octave: 3, pitch: 246.94 },\n  { name: 'E', octave: 4, pitch: 329.63 },\n];\n\nconst getTuner = tune => (pitch) => {\n  const note = getNoteFromPitch(pitch);\n  if (!note) {\n    return false;\n  }\n\n  if (tune.some(({ name, octave }) => note.name === name && note.octave === octave)) {\n    return note;\n  }\n\n  let lowerOffset = -Infinity;\n\n  const { name, octave } = tune.reduce((acc, item) => {\n    const offset = pitch - item.pitch;\n    if (Math.abs(offset) < Math.abs(lowerOffset)) {\n      lowerOffset = offset;\n      return item;\n    }\n\n    return acc;\n  }, {});\n\n  return { name, octave, cents: (lowerOffset < 0 ? -50 : 50) };\n};\n\nexport const chromatic = {\n  name: 'Chromatic',\n  tuner: pitch => getNoteFromPitch(pitch),\n};\n\nexport const standart = {\n  name: 'Standart',\n  tuner: getTuner(standartTuning),\n};\n","const canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nconst arcX = canvas.width / 2;\nconst arcY = canvas.height;\nconst arcRadius = canvas.width / 2;\nconst arcHeight = 3;\nconst startAngleIndex = 1.2;\nconst endAngleIndex = 1.8;\nconst centerAngleIndex = (startAngleIndex + endAngleIndex) / 2;\nconst centsPerAngleIndex = (endAngleIndex - startAngleIndex) / 100;\nconst startAngle = startAngleIndex * Math.PI;\nconst endAngle = endAngleIndex * Math.PI;\n\nconst digits = [-50, -40, -30, -20, -10, 0, 10, 20, 30, 40, 50];\nconst step = (endAngleIndex - startAngleIndex) / (digits.length - 1);\nconst digitsOffsetFromArc = 20;\nconst tickLength = 8;\nconst tickWidth = 2;\nconst digitsAngles = digits.map((digit, index) => (startAngleIndex + (step * index)) * Math.PI);\nconst digitsCoords = digits.map((digit, index) =>\n  ({\n    x: arcX + ((arcRadius + digitsOffsetFromArc) * Math.cos(digitsAngles[index])),\n    y: arcY + ((arcRadius + digitsOffsetFromArc) * Math.sin(digitsAngles[index])),\n  }));\nconst ticksCoords = digits.map((digit, index) =>\n  ({\n    fromX: arcX + (arcRadius * Math.cos(digitsAngles[index])),\n    fromY: arcY + (arcRadius * Math.sin(digitsAngles[index])),\n    toX: arcX + ((arcRadius - tickLength) * Math.cos(digitsAngles[index])),\n    toY: arcY + ((arcRadius - tickLength) * Math.sin(digitsAngles[index])),\n  }));\n\nconst arrowWidth = 3;\nconst arrowLength = 50;\n\nconst noteFontSize = 50;\nconst noteY = (arcY - arcRadius) + arrowLength + (noteFontSize / 2);\n\nconst animationFramesCount = 15;\n\nconst lightsElements = document.querySelectorAll('.lightbulb');\n\nconst state = {\n  arrowAngleIndex: startAngleIndex,\n  lastAnimationId: null,\n};\n\nconst drawLightbulbs = (cents) => {\n  let lightbulbType = '';\n\n  if (cents >= -5 && cents <= 5) {\n    lightbulbType = 'normal';\n  } else if (cents > 5) {\n    lightbulbType = 'dies';\n  } else {\n    lightbulbType = 'bemole';\n  }\n\n  lightsElements.forEach(({ classList }) => {\n    if (classList.contains(`lightbulb-${lightbulbType}`)) {\n      classList.add('active');\n      return;\n    }\n    classList.remove('active');\n  });\n};\n\nconst drawArc = () => {\n  ctx.beginPath();\n  ctx.arc(arcX, arcY, arcRadius, startAngle, endAngle, false);\n  ctx.lineWidth = arcHeight;\n  ctx.strokeStyle = '#000000';\n  ctx.stroke();\n};\n\nconst drawNote = (name) => {\n  ctx.font = `bold ${noteFontSize}px Tahoma`;\n  ctx.fillStyle = '#161616';\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.fillText(name, arcRadius, noteY);\n};\n\nconst drawDigits = () => {\n  digits.forEach((digit, index) => {\n    const { x, y } = digitsCoords[index];\n\n    ctx.font = '16px Tahoma';\n    ctx.fillStyle = '#000000';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(digit, x, y);\n  });\n};\n\nconst drawTicks = () => {\n  digits.forEach((digit, index) => {\n    const {\n      fromX,\n      fromY,\n      toX,\n      toY,\n    } = ticksCoords[index];\n\n    ctx.beginPath();\n    ctx.moveTo(fromX, fromY);\n    ctx.lineTo(toX, toY);\n    ctx.lineWidth = tickWidth;\n    ctx.lineCap = 'butt';\n    ctx.strokeStyle = '#000000';\n    ctx.stroke();\n  });\n};\n\nconst drawArrow = (arrowAngleIndex) => {\n  const angle = arrowAngleIndex * Math.PI;\n  const fromX = arcX + ((arcRadius - arrowLength) * Math.cos(angle));\n  const fromY = arcY + ((arcRadius - arrowLength) * Math.sin(angle));\n  const toX = arcX + (arcRadius * Math.cos(angle));\n  const toY = arcY + (arcRadius * Math.sin(angle));\n\n  ctx.beginPath();\n  ctx.moveTo(fromX, fromY);\n  ctx.lineTo(toX, toY);\n  ctx.lineWidth = arrowWidth;\n  ctx.lineCap = 'round';\n  ctx.strokeStyle = '#c41f09';\n  ctx.stroke();\n};\n\nconst drawScale = (name, arrowAngleIndex) => {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  drawArc();\n  drawDigits();\n  drawTicks();\n  drawNote(name);\n  drawArrow(arrowAngleIndex);\n};\n\nexport default (note) => {\n  if (!note) {\n    return;\n  }\n\n  const { name, octave, cents } = note;\n  const noteName = name ? `${name}${octave}` : '';\n  const resultIndex = centerAngleIndex + (cents * centsPerAngleIndex);\n  const offset = resultIndex - state.arrowAngleIndex;\n  const angleIndexStep = offset / animationFramesCount;\n\n  const animateArrow = () => {\n    if (Math.abs(resultIndex - state.arrowAngleIndex) <= Math.abs(angleIndexStep)) {\n      drawScale(noteName, resultIndex);\n      state.arrowAngleIndex = resultIndex;\n      return;\n    }\n\n    state.arrowAngleIndex += angleIndexStep;\n    drawScale(noteName, state.arrowAngleIndex);\n    state.lastAnimationId = window.requestAnimationFrame(animateArrow);\n  };\n\n  drawLightbulbs(cents);\n  cancelAnimationFrame(state.lastAnimationId);\n  state.lastAnimationId = window.requestAnimationFrame(animateArrow);\n};\n","import { findPitch } from 'pitchy';\nimport * as tuners from './tuners';\nimport render from './render';\n\nlet getNote = tuners.chromatic.tuner;\n\nconst selectElement = document.querySelector('.tunings');\nselectElement.innerHTML =\n  `<select>${Object.keys(tuners).map(key => `<option value=${key}>${tuners[key].name}</option>`).join('')}</select>`;\n\nselectElement.addEventListener('change', () => {\n  getNote = tuners[selectElement.value].tuner;\n});\n\nrender({ cents: -50 });\n\nwindow.navigator.mediaDevices.getUserMedia({ audio: true })\n  .then((stream) => {\n    const context = new AudioContext();\n    const source = context.createMediaStreamSource(stream);\n\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 2048;\n    const data = new Float32Array(analyser.fftSize);\n\n    const destination = context.createMediaStreamDestination();\n\n    source.connect(analyser).connect(destination);\n\n    setInterval(() => {\n      analyser.getFloatTimeDomainData(data);\n      const [pitch, clarity] = findPitch(data, context.sampleRate);\n\n      if (clarity > 0.9) {\n        render(getNote(pitch));\n      }\n    }, 100);\n  });\n"]}